<!DOCTYPE html>
<html>
<head>
    <title>Baco V1.2 - FINAL Save/Load DEBUG</title>
    <meta charset="UTF-8">
    <style>
        /* CSS bleibt unver√§ndert */
        body { margin: 0; overflow: hidden; font-family: 'Arial', sans-serif; background: linear-gradient(to bottom, #1e90ff, #5f9ea0, #8a2be2); color: #fff; display: flex; align-items: center; justify-content: center; height: 100vh; transition: background 1s ease-in-out; }
        .menu { background: rgba(0, 0, 0, 0.8); padding: 20px; border-radius: 10px; text-align: center; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 450px; max-height: 85vh; overflow-y: auto; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5); display: none; z-index: 10; }
        #spiel { background: rgba(0, 0, 0, 0.3); border-radius: 8px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 80%; height: 80%; z-index: 1; overflow: hidden; box-shadow: 0 0 15px rgba(0,0,0,0.4); display: none; }
        #spielCanvas { display: block; width: 100%; height: 100%; }
        button { background: #fff; color: #333; border: none; padding: 10px 15px; margin: 5px; border-radius: 5px; cursor: pointer; transition: background 0.3s ease; font-size: 0.9em; }
        button:hover { background: #e0e0e0; }
        button:disabled { background: #ccc; cursor: not-allowed; opacity: 0.7; }
        #adminInput { background-color: white; color: black; border: none; padding: 8px; border-radius: 5px; margin-bottom: 10px; width: calc(100% - 22px); box-sizing: border-box; }
        #versionsKennzeichnung { font-size: 14px; color: #fff; position: absolute; bottom: 10px; left: 10px; z-index: 5; }
        .ability-entry, .upgrade-entry, .shop-entry { border-bottom: 1px solid #555; padding-bottom: 10px; margin-bottom: 10px; display: flex; flex-wrap: wrap; justify-content: space-between; align-items: center; }
        .ability-entry:last-child, .upgrade-entry:last-child, .shop-entry:last-child { border-bottom: none; }
        .ability-info, .upgrade-info, .shop-info { text-align: left; flex-basis: 60%; }
        .ability-actions, .upgrade-actions, .shop-actions { text-align: right; flex-basis: 35%; }
        .ability-status, .upgrade-status, .shop-status { font-size: 0.9em; color: #ccc; display: block; margin-bottom: 5px; }
        .detail-stats { font-size: 0.8em; color: #bbb; display: block; margin-top: 3px; }
        .upgrade-button, .unlock-button { padding: 5px 10px; font-size: 0.8em; margin-left: 5px; color: white; }
        .upgrade-button { background-color: #4CAF50; } .unlock-button { background-color: #007bff; }
        .upgrade-button:disabled, .unlock-button:disabled { background-color: #aaa; }
        .menu h2 { margin-top: 0; }
        #manual-kofi-link { position: fixed; top: 15px; right: 15px; background-color: #72a4f2; color: white; padding: 8px 15px; border-radius: 5px; text-decoration: none; font-family: 'Arial', sans-serif; font-size: 0.9em; z-index: 10000; transition: background-color 0.3s ease; }
        #manual-kofi-link:hover { background-color: #5a8cd8; }
    </style>
</head>
<body>
    <a href="https://ko-fi.com/bacogame" target="_blank" id="manual-kofi-link">Support Baco on Ko-fi</a>
    <div id="spiel"> <canvas id="spielCanvas"></canvas> </div>
    <div id="hauptMenu" class="menu"><h2>Baco</h2><p>Catch Bacos. Avoid misses (except green!). Unlock and use abilities!</p><button id="spielStartenMenu">Start Game</button><button id="shopOeffnenButton">Shop</button><button id="myAbilitiesOeffnenButton">My Abilities</button><button id="upgradesOeffnenMenu">Passive Upgrades</button><button id="breadoAnzeigenButton">Breados</button><span id="versionsKennzeichnung">V1.2</span></div>
    <div id="modusAuswahl" class="menu"><h2>Choose Mode</h2><button id="starteNormalModus">Normal Mode</button><button id="starteWellenModus">Wave Mode</button><button id="zurueckZumHauptmenu">Back</button></div>
    <div id="gameOver" class="menu"><h2>Game Over</h2><p id="gameOverNachricht"></p><p>Final Score: <span id="gameOverScore">0</span></p><button id="gameOverOk">OK</button></div>
    <div id="shopMenu" class="menu"><h2>Ability Shop</h2><p style="font-size:0.9em; color:#ccc;">Unlock new abilities with your Breados!</p><div id="shopList"></div><button id="shopSchliessenButton" style="margin-top: 20px;">Close</button></div>
    <div id="myAbilitiesMenu" class="menu"><h2>My Abilities & Upgrades</h2><p style="font-size:0.9em; color:#ccc;">View stats of your unlocked abilities and upgrade them.</p><div id="abilitiesList"></div><button id="myAbilitiesSchliessenButton" style="margin-top: 20px;">Close</button></div>
    <div id="upgradesMenu" class="menu"><h2>Passive Upgrades</h2><p style="font-size:0.9em; color:#ccc;">Permanently improve your stats with Breados.</p><div id="passiveUpgradesList"></div><button id="upgradesSchliessen" style="margin-top: 20px;">Close</button></div>
    <div id="adminPanel" class="menu"> <h2>Admin Panel</h2> <input type="text" id="adminInput" placeholder="Enter Command"> <button id="adminExecute">Execute</button> <button id="adminSchliessen">Close</button></div>
    <div id="messageBox" class="menu"> <h2 id="messageBoxTitle"></h2> <p id="messageBoxText"></p> <button id="messageBoxOk">OK</button></div>
    <div id="breadoMenu" class="menu"><h2>Your Breados</h2><p style="font-size: 1.5em; margin: 15px 0;"> <span id="breadoAnzeigeText">0</span> Br</p><p style="font-size: 0.9em; margin-top: 15px;">Best Combo: <span id="bestComboAnzeigeText">0</span>x</p><button id="breadoMenuZurueck">Back</button></div>

    <script>
        const spielDiv = document.getElementById('spiel');
        const canvas = document.getElementById('spielCanvas');
        const ctx = canvas.getContext('2d');
        const hauptMenu = document.getElementById('hauptMenu');
        const modusAuswahlMenu = document.getElementById('modusAuswahl');
        const shopMenu = document.getElementById('shopMenu');
        const myAbilitiesMenu = document.getElementById('myAbilitiesMenu');
        const upgradesMenu = document.getElementById('upgradesMenu');
        const adminPanel = document.getElementById('adminPanel');
        const gameOverMenu = document.getElementById('gameOver');
        const messageBox = document.getElementById('messageBox');
        const breadoMenu = document.getElementById('breadoMenu');
        const spielStartenMenuButton = document.getElementById('spielStartenMenu');
        const shopOeffnenButton = document.getElementById('shopOeffnenButton');
        const myAbilitiesOeffnenButton = document.getElementById('myAbilitiesOeffnenButton');
        const upgradesOeffnenMenu = document.getElementById('upgradesOeffnenMenu');
        const breadoAnzeigenButton = document.getElementById('breadoAnzeigenButton');
        const starteNormalModusButton = document.getElementById('starteNormalModus');
        const starteWellenModusButton = document.getElementById('starteWellenModus');
        const zurueckZumHauptmenuButton = document.getElementById('zurueckZumHauptmenu');
        const shopSchliessenButton = document.getElementById('shopSchliessenButton');
        const myAbilitiesSchliessenButton = document.getElementById('myAbilitiesSchliessenButton');
        const upgradesSchliessenButton = document.getElementById('upgradesSchliessen');
        const gameOverNachrichtText = document.getElementById('gameOverNachricht');
        const gameOverScoreSpan = document.getElementById('gameOverScore');
        const gameOverOkButton = document.getElementById('gameOverOk');
        const adminInput = document.getElementById('adminInput');
        const adminExecuteButton = document.getElementById('adminExecute');
        const adminSchliessenButton = document.getElementById('adminSchliessen');
        const messageBoxTitle = document.getElementById('messageBoxTitle');
        const messageBoxText = document.getElementById('messageBoxText');
        const messageBoxOkButton = document.getElementById('messageBoxOk');
        const breadoAnzeigeText = document.getElementById('breadoAnzeigeText');
        const bestComboAnzeigeText = document.getElementById('bestComboAnzeigeText');
        const breadoMenuZurueck = document.getElementById('breadoMenuZurueck');
        const shopListDiv = document.getElementById('shopList');
        const abilitiesListDiv = document.getElementById('abilitiesList');
        const passiveUpgradesListDiv = document.getElementById('passiveUpgradesList');

        const FARBEN = { weiss: '#fff', rot: '#f00', blau: '#007bff', gruen: '#28a745', dunkelgruen: '#006400', schwarz_transparent: 'rgba(0, 0, 0, 0.5)', pause_text: '#fff', info_text: '#fff', wave_text: '#ccc', combo_text: '#ffcc00' };
        const BACO_EINSTELLUNGEN = { groesse: 20, grundGeschwindigkeit: 2, maxGeschwindigkeit: 10, slowMoFaktor: 0.5, schwierigkeit: { normal: 1, schwer: 2, bonusGruen: 4, extremSchwer: 5 }, spawnRateBasis: 0.02, maxSpawnRate: 0.2, spawnRateSteigerungDivisor: 10000, geschwindigkeitSteigerungDivisor: 500, waveModeSpawnRate: 0.06 };
        const FONT_EINSTELLUNGEN = { score: '20px Arial', pause: '30px Arial', admin_hinweis: '30px Arial', wave: '14px Arial', combo: '24px Arial Black' };
        const HINTERGRUENDE = ['linear-gradient(to bottom, #4a148c, #880e4f)', 'linear-gradient(to bottom, #1e90ff, #5f9ea0, #8a2be2)', 'linear-gradient(to bottom, #ff6f61, #6b5b95, #88b04b)', 'linear-gradient(to bottom, #f7cac9, #92a8d1, #955251)'];
        const HINTERGRUND_WECHSEL_INTERVALL_MS = 15000;
        const FPS = 60;
        const START_LIVES_NORMAL = 3;
        const WAVE_MODE_START_LIVES_BASE = 20;
        const MOUSE_HITBOX_RADIUS_BASE = 5;
        const UPGRADE_COSTS = [1000, 2000, 3000, 4000, 5000];
        const COMBO_TIMEOUT_FRAMES = 3 * FPS;

        let punkte = 0; let highscore = 0; let breados = 0; let bestCombo = 0;
        let unlockedAbilities = ['slowMo'];
        // Level NICHT mehr als globale Variablen, werden direkt in den Objekten gehalten
        let given100PtReward = false; let given1000PtReward = false; let given10000PtEventTriggered = false;
        let bacos = []; let leben = 3; let aktuellerModus = 'normal'; let currentWave = 0;
        let spielLaeuft = false; let spielAktiv = true; let unendlichLeben = false; let noCooldownAdmin = false;
        let gameLoopId = null; let hintergrundIntervalId = null; let aktuelleSpawnRate = BACO_EINSTELLUNGEN.spawnRateBasis; let aktuelleBasisGeschwindigkeit = BACO_EINSTELLUNGEN.grundGeschwindigkeit;
        let aktuellerHintergrundIndex = Math.floor(Math.random() * HINTERGRUENDE.length);
        let questsAktiv = false; let questsFortschritt = { bacosGefangen: 0, blaueBacosGefangen: 0, highscoreErreicht: false };
        let currentCombo = 0; let comboTimer = 0;

        const abilities = [
            { id: 'slowMo', name: 'Slow-Mo', description: 'Slows down all Bacos (Key: S).', breadoCost: 0, activationKey: 's', maxLevel: 5, baseDurationFrames: 10 * FPS, durationIncreasePerLevel: 1 * FPS, baseCooldownFrames: 20 * FPS, baseCooldownFramesWave: 10 * FPS, cooldownReductionPerLevel: 0.08, state: 'ready', remainingDuration: 0, remainingCooldown: 0, level: 0, currentCharges: 0, effect: ()=>{}, removeEffect: ()=>{} },
           /* { id: 'magnet', name: 'Magnet', description: 'Automatically attracts Bacos (Key: M).', breadoCost: 5000, activationKey: 'm', maxLevel: 5, baseDurationFrames: 5 * FPS, durationIncreasePerLevel: 0.6 * FPS, baseCooldownFrames: 30 * FPS, baseCooldownFramesWave: 10 * FPS, cooldownReductionPerLevel: 0.05, state: 'locked', remainingDuration: 0, remainingCooldown: 0, level: 0, currentCharges: 0, effect: ()=>{}, removeEffect: ()=>{} },*/
            { id: 'shield', name: 'Shield', description: 'Absorbs the next miss (Key: F).', breadoCost: 3000, activationKey: 'f', maxLevel: 5, baseCharges: 1, chargesIncreasePerLevel: 1, baseCooldownFrames: 30 * FPS, baseCooldownFramesWave: 10 * FPS, cooldownReductionPerLevel: 0.06, state: 'locked', remainingDuration: 0, remainingCooldown: 0, level: 0, currentCharges: 0, effect: function() { this.currentCharges = calculateEffectValue(this.id, 'charges', this.level); }, removeEffect: ()=>{} },
            { id: 'multiplier', name: 'Point Multiplier', description: 'Doubles points earned for 10s+ (Key: X).', breadoCost: 7500, activationKey: 'x', maxLevel: 5, baseDurationFrames: 10 * FPS, durationIncreasePerLevel: 1 * FPS, baseCooldownFrames: 30 * FPS, baseCooldownFramesWave: 10 * FPS, cooldownReductionPerLevel: 0.07, state: 'locked', remainingDuration: 0, remainingCooldown: 0, level: 0, currentCharges: 0, effect: ()=>{}, removeEffect: ()=>{} },
            { id: 'push', name: 'Baco Push', description: 'Pushes Bacos upwards (Key: C).', breadoCost: 4000, activationKey: 'c', maxLevel: 5, baseDurationFrames: 0, durationIncreasePerLevel: 0, baseCooldownFrames: 40 * FPS, baseCooldownFramesWave: 10 * FPS, cooldownReductionPerLevel: 0.08, state: 'locked', remainingDuration: 0, remainingCooldown: 0, level: 0, currentCharges: 0, effect: function() { bacos.forEach(baco => { baco.y -= 100; baco.y = Math.max(-BACO_EINSTELLUNGEN.groesse, baco.y); }); }, removeEffect: ()=>{} }
        ];
        let passiveUpgrades = { catchRadius: { name: "Catch Radius", description: "Increases the mouse catch area.", level: 0, maxLevel: 5, costs: UPGRADE_COSTS, baseValue: MOUSE_HITBOX_RADIUS_BASE, bonusPerLevel: 1, uiElementId: 'upgradeCatchRadius' } };

        abilities.forEach(ability => { ability.uiElement = null; ability.statusElement = null; ability.upgradeButton = null; ability.levelDisplay = null; });
        Object.keys(passiveUpgrades).forEach(id => { passiveUpgrades[id].uiStatusElement = null; passiveUpgrades[id].uiUpgradeButton = null; });

        function populateShopMenu() { if (!shopListDiv) return; shopListDiv.innerHTML = ''; abilities.forEach(ability => { const isUnlocked = unlockedAbilities.includes(ability.id); const entry = document.createElement('div'); entry.className = 'shop-entry'; let actionHtml = ''; if (ability.breadoCost > 0 || !isUnlocked) { if (isUnlocked) { actionHtml = `<button disabled>Owned</button>`; } else { actionHtml = `<button class="unlock-button" id="unlock-${ability.id}" data-unlock-id="${ability.id}" ${breados < ability.breadoCost ? 'disabled' : ''}>Unlock (${ability.breadoCost} Br)</button>`; } entry.innerHTML = `<div class="shop-info"> <strong>${ability.name}</strong><br> <span style="font-size:0.8em;">${ability.description}</span> </div> <div class="shop-actions"> ${actionHtml} </div>`; shopListDiv.appendChild(entry); if (!isUnlocked) { const unlockButton = document.getElementById(`unlock-${ability.id}`); if (unlockButton) { unlockButton.addEventListener('click', (e) => tryUnlockAbility(e.target.dataset.unlockId)); } } } }); }
        function populateMyAbilitiesMenu() { if (!abilitiesListDiv) return; abilitiesListDiv.innerHTML = ''; const myAbilities = abilities.filter(a => unlockedAbilities.includes(a.id)); if (myAbilities.length === 0) { abilitiesListDiv.innerHTML = '<p style="color:#aaa;">No abilities unlocked yet. Visit the Shop!</p>'; return; } myAbilities.forEach(ability => { const entry = document.createElement('div'); entry.className = 'ability-entry'; let details = []; const currentDurationSec = calculateEffectValue(ability.id, 'duration', ability.level) / FPS; const currentCooldownSec = calculateEffectValue(ability.id, 'cooldown', ability.level) / FPS; const currentCharges = calculateEffectValue(ability.id, 'charges', ability.level); if (currentDurationSec > 0 && ability.id !== 'shield') details.push(`Duration: ${currentDurationSec.toFixed(1)}s`); if (currentCooldownSec > 0 && ability.id !== 'shield') details.push(`Cooldown: ${currentCooldownSec.toFixed(1)}s`); if (ability.id === 'shield') { details.push(`Charges: ${currentCharges}`); details.push(`Cooldown: ${currentCooldownSec.toFixed(1)}s`); } const nextLevelCost = getUpgradeCost(UPGRADE_COSTS, ability.level); const canUpgrade = ability.level < ability.maxLevel; const upgradeButtonText = canUpgrade ? `Upgrade (${nextLevelCost} Br)` : 'Max Level'; const upgradeButtonDisabled = !canUpgrade || breados < nextLevelCost; entry.innerHTML = `<div class="ability-info"> <strong>${ability.name}</strong> <span id="level-${ability.id}" style="font-size:0.8em; color:#aaa;">Lvl ${ability.level}/${ability.maxLevel}</span><br> <span class="detail-stats">${details.join(', ')}</span> <span class="ability-status" id="status-${ability.id}"></span> </div> <div class="ability-actions"> <button class="upgrade-button" id="upgrade-${ability.id}" data-ability-id="${ability.id}" ${upgradeButtonDisabled ? 'disabled' : ''}>${upgradeButtonText}</button> </div>`; abilitiesListDiv.appendChild(entry); ability.statusElement = document.getElementById(`status-${ability.id}`); ability.upgradeButton = document.getElementById(`upgrade-${ability.id}`); ability.levelDisplay = document.getElementById(`level-${ability.id}`); if (ability.upgradeButton) { ability.upgradeButton.addEventListener('click', (e) => handleUpgradeButtonClick(e)); } updateAbilityStatusUI(ability); }); }
        function populateUpgradesMenu() { if (!passiveUpgradesListDiv) return; passiveUpgradesListDiv.innerHTML = ''; Object.keys(passiveUpgrades).forEach(id => { const upgrade = passiveUpgrades[id]; const entry = document.createElement('div'); entry.className = 'upgrade-entry'; entry.innerHTML = `<div class="upgrade-info"> <strong>${upgrade.name}</strong><br> <span style="font-size:0.8em;">${upgrade.description}</span><br> <span class="upgrade-status" id="status-${id}"></span> </div> <div class="upgrade-actions"> <button class="upgrade-button" id="${upgrade.uiElementId}" data-upgrade-id="${id}">Upgrade</button> </div>`; passiveUpgradesListDiv.appendChild(entry); upgrade.uiStatusElement = document.getElementById(`status-${id}`); upgrade.uiUpgradeButton = document.getElementById(upgrade.uiElementId); if(upgrade.uiUpgradeButton) { upgrade.uiUpgradeButton.addEventListener('click', (e) => handleUpgradeButtonClick(e)); } }); updateUpgradesMenuUI(); }
        function getUpgradeCost(costsArray, currentLevel) { if (currentLevel >= costsArray.length) return Infinity; return costsArray[currentLevel]; }
        function calculateEffectValue(id, property, level) { const item = abilities.find(a => a.id === id) || passiveUpgrades[id]; if (!item) return 0; switch(property) { case 'duration': return item.baseDurationFrames + level * item.durationIncreasePerLevel; case 'cooldown': const baseCD = (aktuellerModus === 'wave' && item.baseCooldownFramesWave !== undefined) ? item.baseCooldownFramesWave : item.baseCooldownFrames; return Math.max(1 * FPS, Math.round(baseCD * (1 - level * item.cooldownReductionPerLevel))); case 'charges': return item.baseCharges + level * item.chargesIncreasePerLevel; case 'multiplier': return 2; case 'catchRadius': return item.baseValue + level * item.bonusPerLevel; default: return item.baseValue !== undefined ? item.baseValue : 0; } }
        function resizeCanvas() { if (!spielDiv) { return; } const spielRect = spielDiv.getBoundingClientRect(); if (!canvas) { return; } canvas.width = spielRect.width; canvas.height = spielRect.height; if (spielLaeuft && spielAktiv && ctx) { ctx.fillStyle = FARBEN.schwarz_transparent; ctx.fillRect(0, 0, canvas.width, canvas.height); zeichneBacos(); zeigeSpielInfo(); } }
        window.addEventListener('resize', resizeCanvas);
        function erstelleBaco() { let bacoTypeData = { typ: -1, farbe: '', geschwindigkeitMultiplier: 1 }; let baseSpeed = aktuelleBasisGeschwindigkeit; if (aktuellerModus === 'wave') { let possibleTypes = []; switch (currentWave) { case 1: bacoTypeData = { typ: BACO_EINSTELLUNGEN.schwierigkeit.normal, farbe: FARBEN.weiss, geschwindigkeitMultiplier: 1 }; break; case 2: possibleTypes = [ { weight: 7, data: { typ: BACO_EINSTELLUNGEN.schwierigkeit.normal, farbe: FARBEN.weiss, geschwindigkeitMultiplier: 1 } }, { weight: 3, data: { typ: BACO_EINSTELLUNGEN.schwierigkeit.schwer, farbe: FARBEN.blau, geschwindigkeitMultiplier: BACO_EINSTELLUNGEN.schwierigkeit.schwer } }]; bacoTypeData = selectWeightedRandom(possibleTypes); break; case 3: bacoTypeData = { typ: BACO_EINSTELLUNGEN.schwierigkeit.schwer, farbe: FARBEN.blau, geschwindigkeitMultiplier: BACO_EINSTELLUNGEN.schwierigkeit.schwer }; break; case 4: if (Math.random() < 0.02) { bacoTypeData = { typ: BACO_EINSTELLUNGEN.schwierigkeit.extremSchwer, farbe: FARBEN.dunkelgruen, geschwindigkeitMultiplier: BACO_EINSTELLUNGEN.schwierigkeit.extremSchwer }; } else { possibleTypes = [ { weight: 5, data: { typ: BACO_EINSTELLUNGEN.schwierigkeit.normal, farbe: FARBEN.weiss, geschwindigkeitMultiplier: 1 } }, { weight: 3, data: { typ: BACO_EINSTELLUNGEN.schwierigkeit.schwer, farbe: FARBEN.blau, geschwindigkeitMultiplier: BACO_EINSTELLUNGEN.schwierigkeit.schwer } }, { weight: 2, data: { typ: BACO_EINSTELLUNGEN.schwierigkeit.bonusGruen, farbe: FARBEN.gruen, geschwindigkeitMultiplier: BACO_EINSTELLUNGEN.schwierigkeit.bonusGruen } } ]; bacoTypeData = selectWeightedRandom(possibleTypes); } break; case 5: if (Math.random() < 0.02) { bacoTypeData = { typ: BACO_EINSTELLUNGEN.schwierigkeit.extremSchwer, farbe: FARBEN.dunkelgruen, geschwindigkeitMultiplier: BACO_EINSTELLUNGEN.schwierigkeit.extremSchwer }; } else { possibleTypes = [ { weight: 4, data: { typ: BACO_EINSTELLUNGEN.schwierigkeit.schwer, farbe: FARBEN.blau, geschwindigkeitMultiplier: BACO_EINSTELLUNGEN.schwierigkeit.schwer } }, { weight: 6, data: { typ: BACO_EINSTELLUNGEN.schwierigkeit.bonusGruen, farbe: FARBEN.gruen, geschwindigkeitMultiplier: BACO_EINSTELLUNGEN.schwierigkeit.bonusGruen } } ]; bacoTypeData = selectWeightedRandom(possibleTypes); } break; default: return; } } else { const zufall = Math.random(); if (zufall < 0.02) { bacoTypeData = { typ: BACO_EINSTELLUNGEN.schwierigkeit.extremSchwer, farbe: FARBEN.dunkelgruen, geschwindigkeitMultiplier: BACO_EINSTELLUNGEN.schwierigkeit.extremSchwer }; } else if (zufall < 0.07) { bacoTypeData = { typ: BACO_EINSTELLUNGEN.schwierigkeit.bonusGruen, farbe: FARBEN.gruen, geschwindigkeitMultiplier: BACO_EINSTELLUNGEN.schwierigkeit.bonusGruen }; } else if (zufall < 0.17) { bacoTypeData = { typ: BACO_EINSTELLUNGEN.schwierigkeit.schwer, farbe: FARBEN.blau, geschwindigkeitMultiplier: BACO_EINSTELLUNGEN.schwierigkeit.schwer }; } else { bacoTypeData = { typ: BACO_EINSTELLUNGEN.schwierigkeit.normal, farbe: FARBEN.weiss, geschwindigkeitMultiplier: 1 }; } baseSpeed = aktuelleBasisGeschwindigkeit; } if (bacoTypeData.typ !== -1) { bacos.push({ x: Math.random() * (canvas.width - BACO_EINSTELLUNGEN.groesse), y: -BACO_EINSTELLUNGEN.groesse, geschwindigkeit: baseSpeed * bacoTypeData.geschwindigkeitMultiplier, typ: bacoTypeData.typ, farbe: bacoTypeData.farbe }); } }
        function zeichneBacos() { if (!ctx) return; bacos.forEach(baco => { ctx.fillStyle = baco.farbe; ctx.fillRect(baco.x, baco.y, BACO_EINSTELLUNGEN.groesse, BACO_EINSTELLUNGEN.groesse); }); }
        function zeigeSpielInfo() { if (!ctx) return; ctx.fillStyle = FARBEN.info_text; ctx.font = FONT_EINSTELLUNGEN.score; ctx.textAlign = 'left'; let statusText = `Points: ${punkte} Highscore: ${highscore}`; let currentLives = leben; if (aktuellerModus === 'wave' || aktuellerModus === 'normal') { currentLives = unendlichLeben ? '‚àû' : leben; statusText += ` | Lives: ${currentLives}`; } if (aktuellerModus === 'wave') { statusText += ` | Wave: ${currentWave}`; } ctx.fillText(statusText, 10, 30); if (currentCombo > 1) { ctx.font = FONT_EINSTELLUNGEN.combo; ctx.fillStyle = FARBEN.combo_text; ctx.textAlign = 'center'; ctx.fillText(`${currentCombo}x Combo!`, canvas.width / 2, 60); } if (ctx.canvas.height > 40) { ctx.font = FONT_EINSTELLUNGEN.wave; ctx.fillStyle = FARBEN.wave_text; ctx.textAlign = 'right'; ctx.textBaseline = 'bottom'; ctx.fillText(`Breados: ${breados}`, canvas.width - 10, canvas.height - 10); ctx.textBaseline = 'alphabetic'; } }
        function istMausUeberBaco(mouseX, mouseY, baco) { const currentCatchRadius = calculateEffectValue('catchRadius', passiveUpgrades.catchRadius.level); const bLeft = baco.x; const bRight = baco.x + BACO_EINSTELLUNGEN.groesse; const bTop = baco.y; const bBottom = baco.y + BACO_EINSTELLUNGEN.groesse; const mLeft = mouseX - currentCatchRadius; const mRight = mouseX + currentCatchRadius; const mTop = mouseY - currentCatchRadius; const mBottom = mouseY + currentCatchRadius; return mLeft < bRight && mRight > bLeft && mTop < bBottom && mBottom > bTop; }
        function resetSpiel() {
            console.log(`[DEBUG] resetSpiel START: Current Ability Levels (before reset logic):`, JSON.stringify(abilities.map(a => ({id: a.id, level: a.level}))));
            console.log(`[DEBUG] resetSpiel START: Current Passive Levels (before reset logic):`, JSON.stringify(passiveUpgrades));
            punkte = 0; bacos = []; leben = aktuellerModus === 'wave' ? WAVE_MODE_START_LIVES_BASE : START_LIVES_NORMAL; currentWave = aktuellerModus === 'wave' ? 1 : 0;
            given100PtReward = false; given1000PtReward = false; given10000PtEventTriggered = false;
            aktuelleBasisGeschwindigkeit = BACO_EINSTELLUNGEN.grundGeschwindigkeit; aktuelleSpawnRate = BACO_EINSTELLUNGEN.spawnRateBasis;
            currentCombo = 0; comboTimer = 0;
            // Reset run-time state of abilities, keeping their levels
            abilities.forEach(ability => {
                // Level should already be correct from initialisiereUI or upgrade actions
                 console.log(`[DEBUG] resetSpiel: Resetting state for ${ability.id} (Level ${ability.level})`);
                 if (unlockedAbilities.includes(ability.id)) { ability.state = 'ready'; }
                 else { ability.state = 'locked'; }
                 ability.remainingDuration = 0; ability.remainingCooldown = 0;
                 if(ability.id === 'shield') ability.currentCharges = 0;
            });
            // Passive levels don't have runtime state to reset here
            updateAllUI();
            console.log(`[DEBUG] resetSpiel END: Levels after reset logic:`, JSON.stringify(abilities.map(a => ({id: a.id, level: a.level}))), JSON.stringify(passiveUpgrades));
        }
        function starteSpiel(modus) { if (!hauptMenu || !modusAuswahlMenu || !myAbilitiesMenu || !gameOverMenu || !messageBox || !adminPanel || !breadoMenu || !spielDiv || !upgradesMenu || !shopMenu) { return; } aktuellerModus = modus; resetSpiel(); spielLaeuft = true; spielAktiv = true; hauptMenu.style.display = 'none'; modusAuswahlMenu.style.display = 'none'; myAbilitiesMenu.style.display = 'none'; gameOverMenu.style.display = 'none'; messageBox.style.display = 'none'; adminPanel.style.display = 'none'; breadoMenu.style.display = 'none'; upgradesMenu.style.display = 'none'; shopMenu.style.display = 'none'; spielDiv.style.display = 'block'; resizeCanvas(); if (gameLoopId !== null) cancelAnimationFrame(gameLoopId); gameLoopId = requestAnimationFrame(gameLoop); if (hintergrundIntervalId !== null) clearInterval(hintergrundIntervalId); aendereHintergrund(); hintergrundIntervalId = setInterval(aendereHintergrund, HINTERGRUND_WECHSEL_INTERVALL_MS); }
        function zeigeGameOver(nachricht) { spielLaeuft = false; spielAktiv = false; if (gameLoopId !== null) { cancelAnimationFrame(gameLoopId); gameLoopId = null; } if (hintergrundIntervalId !== null) { clearInterval(hintergrundIntervalId); hintergrundIntervalId = null; } let earnedBreados = punkte; breados += earnedBreados; let breadoMessage = ` (+${earnedBreados} Breados!)`; if (punkte > highscore) { highscore = punkte; } if(gameOverScoreSpan) gameOverScoreSpan.textContent = punkte; if(gameOverNachrichtText) gameOverNachrichtText.textContent = nachricht + breadoMessage; if(spielDiv) spielDiv.style.display = 'none'; if(gameOverMenu) gameOverMenu.style.display = 'block'; }
        function triggerSpecialGameOver() { if(given10000PtEventTriggered) return; given10000PtEventTriggered = true; spielLaeuft = false; spielAktiv = false; if (gameLoopId !== null) cancelAnimationFrame(gameLoopId); gameLoopId = null; if (hintergrundIntervalId !== null) clearInterval(hintergrundIntervalId); hintergrundIntervalId = null; let finalScore = punkte; let earnedBreados = finalScore; breados += earnedBreados; if (finalScore > highscore) highscore = finalScore; showMessageBox( 'good job fella I¬¥d hope the bacos never existed but you did a great job well I think now I will programm more because of you you are now a /(!&"¬ß)&$((&("!$!&¬ß$&!)¬ß/$&!")$/&!")/&$!"&$)!"&$)!/%$)!(%', 'Congratulations?!', () => { if(spielDiv) spielDiv.style.display = 'none'; resetSpiel(); if(hauptMenu) hauptMenu.style.display = 'block'; speicherePersistentData(); }); }
        function triggerWaveWin() { spielLaeuft = false; spielAktiv = false; if (gameLoopId !== null) cancelAnimationFrame(gameLoopId); gameLoopId = null; if (hintergrundIntervalId !== null) clearInterval(hintergrundIntervalId); hintergrundIntervalId = null; let finalScore = punkte; let earnedBreados = finalScore; breados += earnedBreados; if (finalScore > highscore) highscore = finalScore; showMessageBox( "You are probably the best player but you defeated the bacos :) you are the best", "Victory!", () => { if(spielDiv) spielDiv.style.display = 'none'; resetSpiel(); if(hauptMenu) hauptMenu.style.display = 'block'; speicherePersistentData(); }); }
        function processCatch(bacoIndex) { const baco = bacos[bacoIndex]; if (!baco) return; let multiplierAbility = abilities.find(a=>a.id==='multiplier'); let scoreMultiplierValue = (multiplierAbility && multiplierAbility.state === 'active') ? calculateEffectValue('multiplier', multiplierAbility.level) : 1; let punkteWert = 0; const bacoTyp = baco.typ; if (bacoTyp === BACO_EINSTELLUNGEN.schwierigkeit.normal) punkteWert = 5; else if (bacoTyp === BACO_EINSTELLUNGEN.schwierigkeit.schwer) { punkteWert = 10; questsFortschritt.blaueBacosGefangen++; } else if (bacoTyp === BACO_EINSTELLUNGEN.schwierigkeit.bonusGruen) punkteWert = 25; else if (bacoTyp === BACO_EINSTELLUNGEN.schwierigkeit.extremSchwer) punkteWert = 15; currentCombo++; comboTimer = COMBO_TIMEOUT_FRAMES; let earnedPoints = Math.round(punkteWert * scoreMultiplierValue); punkte += earnedPoints; if (currentCombo > bestCombo) { bestCombo = currentCombo; } questsFortschritt.bacosGefangen++; bacos.splice(bacoIndex, 1); }

        function gameLoop(timestamp) {
             if (!spielLaeuft) { gameLoopId = null; return; }
             if (!spielAktiv) { gameLoopId = requestAnimationFrame(gameLoop); return; }
             try {
                 let isSlowMoCurrentlyActive = false; let isMagnetCurrentlyActive = false; let isMultiplierCurrentlyActive = false;
                 let shieldAbility = abilities.find(a => a.id === 'shield');

                 abilities.forEach(ability => {
                     if (ability.state === 'active') {
                         if (ability.id === 'slowMo') isSlowMoCurrentlyActive = true; if (ability.id === 'magnet') isMagnetCurrentlyActive = true; if (ability.id === 'multiplier') isMultiplierCurrentlyActive = true;
                         if (ability.id !== 'shield' && ability.durationFrames > 0 && ability.remainingDuration > 0) {
                             ability.remainingDuration--;
                             if (ability.remainingDuration <= 0) {
                                 console.log(`[DEBUG] Duration ended for ${ability.id}. Setting state to cooldown.`);
                                 ability.state = 'cooldown';
                                 console.log(`[DEBUG] State for ${ability.id} is now: '${ability.state}'`);
                                 ability.remainingCooldown = calculateEffectValue(ability.id, 'cooldown', ability.level);
                                 if (typeof ability.removeEffect === 'function') ability.removeEffect();
                                 if (ability.id === 'slowMo') isSlowMoCurrentlyActive = false; if (ability.id === 'magnet') isMagnetCurrentlyActive = false; if (ability.id === 'multiplier') isMultiplierCurrentlyActive = false;
                             }
                         }
                     } else if (ability.state === 'cooldown') {
                         let currentCooldown = calculateEffectValue(ability.id, 'cooldown', ability.level);
                         if (!noCooldownAdmin && currentCooldown > 0 && ability.remainingCooldown > 0) { ability.remainingCooldown--; if (ability.remainingCooldown <= 0) { ability.state = 'ready'; } }
                         else if (noCooldownAdmin || currentCooldown <= 0) { ability.state = 'ready'; ability.remainingCooldown = 0; }
                     }
                 });
                 updateAllUI();

                 let speedMultiplier = isSlowMoCurrentlyActive ? BACO_EINSTELLUNGEN.slowMoFaktor : 1;
                 let scoreMultiplierValue = isMultiplierCurrentlyActive ? calculateEffectValue('multiplier', abilities.find(a=>a.id==='multiplier').level) : 1;

                 if (aktuellerModus === 'normal') { aktuelleBasisGeschwindigkeit = Math.min(BACO_EINSTELLUNGEN.grundGeschwindigkeit + punkte / BACO_EINSTELLUNGEN.geschwindigkeitSteigerungDivisor, BACO_EINSTELLUNGEN.maxGeschwindigkeit); aktuelleSpawnRate = Math.min(BACO_EINSTELLUNGEN.spawnRateBasis + punkte / BACO_EINSTELLUNGEN.spawnRateSteigerungDivisor, BACO_EINSTELLUNGEN.maxSpawnRate); } else { aktuelleBasisGeschwindigkeit = BACO_EINSTELLUNGEN.grundGeschwindigkeit; aktuelleSpawnRate = BACO_EINSTELLUNGEN.waveModeSpawnRate; }
                 if (comboTimer > 0) comboTimer--; else if (currentCombo > 0) { currentCombo = 0; }

                 let magnetAbility = abilities.find(a => a.id === 'magnet'); let magnetCheckState = magnetAbility ? magnetAbility.state : 'NOT FOUND';
                 if (magnetCheckState === 'active') { for (let i = bacos.length - 1; i >= 0; i--) { processCatch(i); } }

                 for (let i = bacos.length - 1; i >= 0; i--) { const baco = bacos[i]; if (!baco) continue; let aktuelleBacoGeschwindigkeit = baco.geschwindigkeit * speedMultiplier; baco.y += aktuelleBacoGeschwindigkeit; if (baco.y > canvas.height) { const verpassterBacoTyp = baco.typ; bacos.splice(i, 1); currentCombo = 0; comboTimer = 0; let applyPenalty = false; if (!unendlichLeben) { if (aktuellerModus === 'wave') { if (verpassterBacoTyp === BACO_EINSTELLUNGEN.schwierigkeit.bonusGruen) { if (currentWave >= 4) applyPenalty = true; } else { applyPenalty = true; } } else { if (verpassterBacoTyp !== BACO_EINSTELLUNGEN.schwierigkeit.bonusGruen && verpassterBacoTyp !== BACO_EINSTELLUNGEN.schwierigkeit.extremSchwer) { applyPenalty = true; } } } if (applyPenalty) { if (shieldAbility && shieldAbility.state === 'active' && shieldAbility.currentCharges > 0) { shieldAbility.currentCharges--; if (shieldAbility.currentCharges <= 0) { shieldAbility.state = 'cooldown'; shieldAbility.remainingCooldown = calculateEffectValue(shieldAbility.id, 'cooldown', shieldAbility.level); if(typeof shieldAbility.removeEffect === 'function') shieldAbility.removeEffect(); } updateAbilityStatusUI(shieldAbility); } else { leben--; if (leben <= 0) { zeigeGameOver(aktuellerModus === 'wave' ? "Wave Failed!" : "You ran out of lives!"); return; } } } } }
                 if (Math.random() < aktuelleSpawnRate) erstelleBaco();
                 if (aktuellerModus === 'wave') { let waveBeforeUpdate = currentWave; if (punkte < 100) currentWave = 1; else if (punkte < 1000) currentWave = 2; else if (punkte < 2000) currentWave = 3; else if (punkte < 3000) currentWave = 4; else if (punkte < 5000) currentWave = 5; else { triggerWaveWin(); return; } if (currentWave !== waveBeforeUpdate) {} }
                 if (!given100PtReward && punkte >= 100) { breados += 10; given100PtReward = true; }
                 if (!given1000PtReward && punkte >= 1000) { breados += 1000; given1000PtReward = true; }
                 if (!given10000PtEventTriggered && punkte >= 10000) { triggerSpecialGameOver(); return; }
                 if (punkte > highscore) highscore = punkte;
                 if(ctx) { ctx.fillStyle = FARBEN.schwarz_transparent; ctx.fillRect(0, 0, canvas.width, canvas.height); zeichneBacos(); zeigeSpielInfo(); }
             } catch (error) { console.error("Error in gameLoop:", error); if(spielLaeuft) zeigeGameOver("A critical error occurred!"); spielLaeuft = false; return; }
             gameLoopId = requestAnimationFrame(gameLoop);
        }

        function speicherePersistentData() { console.log("[DEBUG] Saving persistent data START"); try { let currentAbilityLevels = {}; abilities.forEach(a => { currentAbilityLevels[a.id] = a.level; }); let currentPassiveLevels = {}; Object.keys(passiveUpgrades).forEach(id => { currentPassiveLevels[id] = passiveUpgrades[id].level; }); localStorage.setItem('bacoHighscore', highscore.toString()); console.log(`[DEBUG] Saving Highscore: ${highscore}`); localStorage.setItem('bacoBreados', breados.toString()); console.log(`[DEBUG] Saving Breados: ${breados}`); localStorage.setItem('bacoBestCombo', bestCombo.toString()); console.log(`[DEBUG] Saving BestCombo: ${bestCombo}`); localStorage.setItem('bacoUnlockedAbilities', JSON.stringify(unlockedAbilities)); console.log("[DEBUG] Saving Unlocked Abilities:", unlockedAbilities); localStorage.setItem('bacoAbilityLevels', JSON.stringify(currentAbilityLevels)); console.log("[DEBUG] Saving Ability Levels:", currentAbilityLevels); localStorage.setItem('bacoPassiveLevels', JSON.stringify(currentPassiveLevels)); console.log("[DEBUG] Saving Passive Levels:", currentPassiveLevels); console.log("[DEBUG] --- Saving Persistent Data SUCCESS ---"); } catch (e) { console.error("!!!!!!!! ERROR saving persistent data:", e); showMessageBox("Error saving progress! Progress might be lost.", "Save Error");} }
        function aendereHintergrund() { aktuellerHintergrundIndex = (aktuellerHintergrundIndex + 1) % HINTERGRUENDE.length; const neuerHintergrund = HINTERGRUENDE[aktuellerHintergrundIndex]; document.body.style.background = neuerHintergrund; }
        function showMessageBox(text, title = "Info", onOkCallback = null) { if(messageBoxTitle) messageBoxTitle.textContent = title; if(messageBoxText) messageBoxText.textContent = text; if(messageBox) messageBox._onOkCallback = onOkCallback; if(messageBox) messageBox.style.display = 'block'; if (spielLaeuft) spielAktiv = false; }
        function updateAllUI() { if(myAbilitiesMenu?.style.display === 'block') { populateMyAbilitiesMenu(); } if(upgradesMenu?.style.display === 'block') { updateUpgradesMenuUI(); } if(shopMenu?.style.display === 'block') { populateShopMenu(); } }
        function updateAbilityStatusUI(ability) { if (!ability?.statusElement || !ability.upgradeButton || !ability.levelDisplay) return; let statusText = ""; let upgradeButtonDisabled = true; let levelText = `Lvl ${ability.level}`; const nextLevelCost = getUpgradeCost(UPGRADE_COSTS, ability.level); upgradeButtonDisabled = breados < nextLevelCost || ability.level >= ability.maxLevel; let currentCooldown = calculateEffectValue(ability.id, 'cooldown', ability.level); switch(ability.state) { case 'ready': statusText = `Ready (Key: ${ability.activationKey.toUpperCase()})`; break; case 'active': if (ability.id === 'shield') { statusText = `Active (${ability.currentCharges} charge(s))`; } else { statusText = `Active! ${Math.ceil(ability.remainingDuration / FPS)}s left`; } break; case 'cooldown': statusText = `Cooldown: ${Math.ceil(ability.remainingCooldown / FPS)}s`; break; default: statusText = "Unknown"; } if (noCooldownAdmin && currentCooldown > 0 && ability.state !== 'active') { statusText = `Ready (No CD / Key: ${ability.activationKey.toUpperCase()})`; } ability.statusElement.textContent = statusText; ability.levelDisplay.textContent = levelText; ability.upgradeButton.disabled = upgradeButtonDisabled; ability.upgradeButton.textContent = ability.level < ability.maxLevel ? `Upgrade (${nextLevelCost} Br)` : 'Max Level'; }
        function updateUpgradesMenuUI() { if (!passiveUpgradesListDiv) return; Object.keys(passiveUpgrades).forEach(id => { const upgrade = passiveUpgrades[id]; const statusElement = document.getElementById(`status-${id}`); const upgradeButton = document.getElementById(upgrade.uiElementId); if (!statusElement || !upgradeButton) { return; } const currentValue = calculateEffectValue(id, id, upgrade.level); const nextLevelCost = getUpgradeCost(UPGRADE_COSTS, upgrade.level); const canUpgrade = upgrade.level < upgrade.maxLevel && breados >= nextLevelCost; let effectText = ""; if(id === 'catchRadius') effectText = `Current Radius Bonus: +${currentValue - upgrade.baseValue}px`; statusElement.textContent = `Level: ${upgrade.level} / ${upgrade.maxLevel}. ${effectText}`; upgradeButton.disabled = !canUpgrade || upgrade.level >= upgrade.maxLevel; upgradeButton.textContent = upgrade.level < upgrade.maxLevel ? `Upgrade (${nextLevelCost} Br)` : 'Max Level'; }); }
        function handleAbilityButtonClick(abilityId) { const ability = abilities.find(a => a.id === abilityId); if (!ability) return; const isUnlocked = unlockedAbilities.includes(ability.id); if (!isUnlocked) { tryUnlockAbility(abilityId); } else { showMessageBox(`${ability.name} is unlocked. Use key '${ability.activationKey.toUpperCase()}' during the game to activate.`, "Info"); } }
        function tryUnlockAbility(abilityId) { const ability = abilities.find(a => a.id === abilityId); if (!ability || unlockedAbilities.includes(ability.id)) return; if (breados >= ability.breadoCost) { breados -= ability.breadoCost; unlockedAbilities.push(ability.id); ability.level = 0; ability.state = 'ready'; showMessageBox(`${ability.name} unlocked!`, "Ability Unlocked"); speicherePersistentData(); populateShopMenu(); updateUpgradesMenuUI(); updateAllUI(); } else { showMessageBox(`Not enough Breados to unlock ${ability.name}! Need ${ability.breadoCost}, have ${breados}.`, "Error"); } }
        function handleUpgradeButtonClick(event) { const abilityId = event.target.dataset.abilityId; const upgradeId = event.target.dataset.upgradeId; let itemToUpgrade; let itemType; let costsArray = UPGRADE_COSTS; if (abilityId) { itemToUpgrade = abilities.find(a => a.id === abilityId); itemType = 'ability'; } else if (upgradeId) { itemToUpgrade = passiveUpgrades[upgradeId]; itemType = 'passive'; if(itemToUpgrade.costs) costsArray = itemToUpgrade.costs; } if (!itemToUpgrade) return; if (itemToUpgrade.level >= itemToUpgrade.maxLevel) { showMessageBox("Already at max level!", "Info"); return; } const cost = getUpgradeCost(costsArray, itemToUpgrade.level); if (breados >= cost) { breados -= cost; itemToUpgrade.level++; console.log(`[DEBUG] Upgraded ${itemToUpgrade.name || abilityId || upgradeId} to level ${itemToUpgrade.level}. Breados left: ${breados}.`); showMessageBox(`${itemToUpgrade.name} upgraded to Level ${itemToUpgrade.level}!`, "Upgrade Successful"); speicherePersistentData(); if(itemType === 'ability') { populateMyAbilitiesMenu(); } else { updateUpgradesMenuUI(); } populateShopMenu(); } else { showMessageBox(`Not enough Breados! Need ${cost}, have ${breados}.`, "Error"); } }
        function activateAbilityEffect(abilityId) { const ability = abilities.find(a => a.id === abilityId); if (!ability || !unlockedAbilities.includes(ability.id)) return; let currentCooldown = calculateEffectValue(ability.id, 'cooldown', ability.level); const canActivate = ability.state === 'ready' || (noCooldownAdmin && currentCooldown > 0 && ability.state !== 'active'); if (canActivate) { console.log(`[DEBUG] Activating effect for ${ability.name}`); if (typeof ability.effect === 'function') { ability.effect(); } ability.state = 'active'; ability.remainingDuration = calculateEffectValue(ability.id, 'duration', ability.level); if(ability.id === 'shield') { ability.currentCharges = calculateEffectValue(ability.id, 'charges', ability.level); ability.remainingDuration = Infinity; } console.log(`[DEBUG] ${ability.id} activated! Set remainingDuration to: ${ability.remainingDuration} frames, Charges: ${ability.currentCharges}`); updateAbilityStatusUI(ability); } else { console.log(`[DEBUG] ${ability.name} cannot be activated (State: ${ability.state})`); } }
        function zeichnePauseOverlay(text = 'Paused') { if (!spielAktiv && spielLaeuft && ctx) { ctx.fillStyle = 'rgba(0, 0, 0, 0.7)'; ctx.fillRect(0, 0, canvas.width, canvas.height); ctx.fillStyle = FARBEN.pause_text; ctx.font = FONT_EINSTELLUNGEN.pause; ctx.textAlign = 'center'; ctx.fillText(text, canvas.width / 2, canvas.height / 2); ctx.textAlign = 'left'; } }

        if (spielStartenMenuButton) spielStartenMenuButton.addEventListener('click', () => { if(hauptMenu) hauptMenu.style.display = 'none'; if(modusAuswahlMenu) modusAuswahlMenu.style.display = 'block'; });
        if (shopOeffnenButton) shopOeffnenButton.addEventListener('click', () => { if(hauptMenu) hauptMenu.style.display = 'none'; populateShopMenu(); if(shopMenu) shopMenu.style.display = 'block'; });
        if (myAbilitiesOeffnenButton) myAbilitiesOeffnenButton.addEventListener('click', () => { if(hauptMenu) hauptMenu.style.display = 'none'; populateMyAbilitiesMenu(); if(myAbilitiesMenu) myAbilitiesMenu.style.display = 'block'; });
        if (upgradesOeffnenMenu) upgradesOeffnenMenu.addEventListener('click', () => { if(hauptMenu) hauptMenu.style.display = 'none'; populateUpgradesMenu(); if(upgradesMenu) upgradesMenu.style.display = 'block'; });
        if (starteNormalModusButton) starteNormalModusButton.addEventListener('click', () => { starteSpiel('normal'); });
        if (starteWellenModusButton) starteWellenModusButton.addEventListener('click', () => { starteSpiel('wave'); });
        if (zurueckZumHauptmenuButton) zurueckZumHauptmenuButton.addEventListener('click', () => { if(modusAuswahlMenu) modusAuswahlMenu.style.display = 'none'; if(hauptMenu) hauptMenu.style.display = 'block'; });
        if (shopSchliessenButton) shopSchliessenButton.addEventListener('click', () => { if(shopMenu) shopMenu.style.display = 'none'; if(hauptMenu) hauptMenu.style.display = 'block'; });
        if (myAbilitiesSchliessenButton) myAbilitiesSchliessenButton.addEventListener('click', () => { if(myAbilitiesMenu) myAbilitiesMenu.style.display = 'none'; if(hauptMenu) hauptMenu.style.display = 'block'; });
        if (upgradesSchliessenButton) upgradesSchliessenButton.addEventListener('click', () => { if(upgradesMenu) upgradesMenu.style.display = 'none'; if(hauptMenu) hauptMenu.style.display = 'block'; });
        if (gameOverOkButton) gameOverOkButton.addEventListener('click', () => { if(gameOverMenu) gameOverMenu.style.display = 'none'; if(hauptMenu) hauptMenu.style.display = 'block'; speicherePersistentData(); resetSpiel(); });
        if (messageBoxOkButton) messageBoxOkButton.addEventListener('click', () => { if(messageBox) messageBox.style.display = 'none'; if (typeof messageBox._onOkCallback === 'function') { messageBox._onOkCallback(); messageBox._onOkCallback = null; } else if (spielLaeuft && adminPanel?.style.display !== 'block' && myAbilitiesMenu?.style.display !== 'block' && breadoMenu?.style.display !== 'block' && upgradesMenu?.style.display !== 'block' && shopMenu?.style.display !== 'block') { spielAktiv = true; } });
        if (breadoAnzeigenButton) breadoAnzeigenButton.addEventListener('click', () => { if(hauptMenu) hauptMenu.style.display = 'none'; if(breadoAnzeigeText) breadoAnzeigeText.textContent = breados; if(bestComboAnzeigeText) bestComboAnzeigeText.textContent = bestCombo; if(breadoMenu) breadoMenu.style.display = 'block'; });
        if (breadoMenuZurueck) breadoMenuZurueck.addEventListener('click', () => { if(breadoMenu) breadoMenu.style.display = 'none'; if(hauptMenu) hauptMenu.style.display = 'block'; });
        if(canvas) canvas.addEventListener('mousemove', (event) => { if (!spielLaeuft || !spielAktiv) return; const rect = canvas.getBoundingClientRect(); const mouseX = event.clientX - rect.left; const mouseY = event.clientY - rect.top; let magnetAbility = abilities.find(a => a.id === 'magnet'); if (magnetAbility?.state !== 'active') { for (let i = bacos.length - 1; i >= 0; i--) { if (istMausUeberBaco(mouseX, mouseY, bacos[i])) { processCatch(i); break; } } } }); // Mouse catch only if magnet inactive
        if (adminExecuteButton) adminExecuteButton.addEventListener('click', () => { if (!adminInput) return; const command = adminInput.value.trim().toLowerCase(); let message = ""; let title = "Success"; switch(command) { case '/leonbreados100000': breados += 100000; message = "100,000 Breados added!"; updateAllUI(); break; case '/thisneverends': triggerSpecialGameOver(); message="Special event triggered."; break; case '/leonlivesinfinite': unendlichLeben = !unendlichLeben; message = `Infinite Lives ${unendlichLeben ? "activated" : "deactivated"}.`; leben = unendlichLeben ? Infinity : (aktuellerModus === 'wave' ? WAVE_MODE_START_LIVES_BASE : START_LIVES_NORMAL); break; case '/reset': highscore = 0; breados = 0; bestCombo = 0; unlockedAbilities = ['slowMo']; abilities.forEach(a => a.level = 0); Object.keys(passiveUpgrades).forEach(id => passiveUpgrades[id].level = 0); speicherePersistentData(); resetSpiel(); message = "Highscore, Breados, Best Combo, Unlocks and Levels reset!"; break; case '/adminnocooldown': noCooldownAdmin = !noCooldownAdmin; message = `Ability No-Cooldown ${noCooldownAdmin ? "activated" : "deactivated"}!`; if(noCooldownAdmin) { abilities.forEach(a => { if(a.state === 'cooldown') a.remainingCooldown = 0; }); } updateAllUI(); break; case '/pointsreset': punkte = 0; message = "Current round points set to 0!"; break; case '/livesnormal': if (!unendlichLeben) { leben = (aktuellerModus === 'wave' ? WAVE_MODE_START_LIVES_BASE : START_LIVES_NORMAL); message = `Lives reset to base (${leben})!`; } else { message = "Disable Infinite Lives first."; title = "Info"; } break; case '/backtomenu': if (spielLaeuft) zeigeGameOver(aktuellerModus === 'wave' ? "Wave ended by Admin." : "Returned to menu via admin command."); else resetSpiel(); if(adminPanel) adminPanel.style.display = 'none'; if(gameOverMenu) gameOverMenu.style.display = 'none'; if(hauptMenu) hauptMenu.style.display = 'block'; spielAktiv = true; message = "Returned to Main Menu!"; break; case '/startquests': questsAktiv = true; message = "Quests started!"; break; case '/cancelquests': questsAktiv = false; questsFortschritt = { bacosGefangen: 0, blaueBacosGefangen: 0, highscoreErreicht: false }; message = "Quests canceled!"; break; default: if (command.startsWith('/setlives ')) { if (!unendlichLeben) { const amount = parseInt(command.split(' ')[1]); if (!isNaN(amount) && amount >= 0) { leben = amount; message = `Lives set to ${amount}!`; } else { title = "Error"; message = "Invalid lives amount!"; } } else { message = "Disable Infinite Lives first."; title = "Info"; } } else if (command.startsWith('/setlevel ')) { const parts = command.split(' '); if(parts.length === 3) { const itemId = parts[1].toLowerCase(); const level = parseInt(parts[2]); if(!isNaN(level)) { let itemAbility = abilities.find(a => a.id.toLowerCase() === itemId); let itemPassiveId = Object.keys(passiveUpgrades).find(id => id.toLowerCase() === itemId); let itemPassive = itemPassiveId ? passiveUpgrades[itemPassiveId] : null; if (itemAbility) { if(unlockedAbilities.includes(itemAbility.id)){ itemAbility.level = Math.max(0, Math.min(itemAbility.maxLevel, level)); message = `${itemAbility.name} level set to ${itemAbility.level}.`; updateAllUI(); speicherePersistentData(); } else { message = `${itemAbility.name} is not unlocked.`; title="Error";} } else if (itemPassive) { itemPassive.level = Math.max(0, Math.min(itemPassive.maxLevel, level)); message = `${itemPassive.name} level set to ${itemPassive.level}.`; updateAllUI(); speicherePersistentData(); } else { message = `Item '${itemId}' not found.`; title = "Error"; } } else { message = "Invalid level number."; title = "Error"; } } else { message = "Usage: /setlevel <id> <level>"; title="Error"; } } else { title = "Error"; message = "Unknown command!"; } } adminInput.value = ''; if (command !== '/thisneverends') { showMessageBox(message, title); } updateAllUI(); });
        if (adminSchliessenButton) adminSchliessenButton.addEventListener('click', () => { if(adminPanel) adminPanel.style.display = 'none'; if (spielLaeuft && messageBox?.style.display !== 'block' && myAbilitiesMenu?.style.display !== 'block' && breadoMenu?.style.display !== 'block' && upgradesMenu?.style.display !== 'block' && shopMenu?.style.display !== 'block') { spielAktiv = true; } });

        window.addEventListener('keydown', (event) => { const key = event.key.toLowerCase(); if (key === 'y') { const isAdminPanelVisible = adminPanel?.style.display === 'block'; if(adminPanel) adminPanel.style.display = isAdminPanelVisible ? 'none' : 'block'; if (spielLaeuft) { if (isAdminPanelVisible) { if (messageBox?.style.display !== 'block' && myAbilitiesMenu?.style.display !== 'block' && breadoMenu?.style.display !== 'block' && upgradesMenu?.style.display !== 'block' && shopMenu?.style.display !== 'block') { spielAktiv = true; } } else { spielAktiv = false; zeichnePauseOverlay("Admin Panel Active"); } } return; } if (spielLaeuft && spielAktiv) { const abilityToActivate = abilities.find(a => a.activationKey === key); if (abilityToActivate) { activateAbilityEffect(abilityToActivate.id); } } if (spielLaeuft && spielAktiv && key === 'p' && questsAktiv && questsFortschritt.highscoreErreicht) { punkte += 500; showMessageBox("Quest Reward Claimed: +500 Points!", "Quest"); questsFortschritt.highscoreErreicht = false; } });
        window.addEventListener('blur', () => { if (spielLaeuft) { spielAktiv = false; } });
        window.addEventListener('focus', () => { if (spielLaeuft && !spielAktiv) { if (adminPanel?.style.display !== 'block' && messageBox?.style.display !== 'block' && myAbilitiesMenu?.style.display !== 'block' && breadoMenu?.style.display !== 'block' && upgradesMenu?.style.display !== 'block' && shopMenu?.style.display !== 'block') { spielAktiv = true; } else { zeichnePauseOverlay(); } } });

        function initialisiereUI() {
            console.log("[DEBUG] Initializing UI...");
            const menus = [hauptMenu, modusAuswahlMenu, myAbilitiesMenu, upgradesMenu, shopMenu, adminPanel, gameOverMenu, messageBox, breadoMenu, spielDiv];
            if (menus.some(menu => !menu)) { console.error("One or more essential UI elements not found!"); return; }
            menus.forEach(menu => { if(menu !== hauptMenu) menu.style.display = 'none'; });
            if(hauptMenu) hauptMenu.style.display = 'block';
            let loadedAbilityLevels = {}; let loadedPassiveLevels = {};
            try {
                console.log("[DEBUG] --- Loading persistent data START ---");
                const hsRaw = localStorage.getItem('bacoHighscore'); highscore = parseInt(hsRaw || '0'); console.log(`[DEBUG] Highscore: Raw='${hsRaw}', Parsed=${highscore}`);
                const brRaw = localStorage.getItem('bacoBreados'); breados = parseInt(brRaw || '0'); console.log(`[DEBUG] Breados: Raw='${brRaw}', Parsed=${breados}`);
                const bcRaw = localStorage.getItem('bacoBestCombo'); bestCombo = parseInt(bcRaw || '0'); console.log(`[DEBUG] BestCombo: Raw='${bcRaw}', Parsed=${bestCombo}`);
                const savedUnlockedRaw = localStorage.getItem('bacoUnlockedAbilities'); unlockedAbilities = savedUnlockedRaw ? JSON.parse(savedUnlockedRaw) : ['slowMo']; if (!unlockedAbilities.includes('slowMo')) unlockedAbilities.push('slowMo'); console.log(`[DEBUG] Unlocked Abilities: Raw='${savedUnlockedRaw}', Parsed=`, unlockedAbilities);
                const savedAbilityLevelsRaw = localStorage.getItem('bacoAbilityLevels'); loadedAbilityLevels = savedAbilityLevelsRaw ? JSON.parse(savedAbilityLevelsRaw) : {}; console.log("[DEBUG] Ability Levels: Raw=", savedAbilityLevelsRaw, "Parsed:", loadedAbilityLevels);
                const savedPassiveLevelsRaw = localStorage.getItem('bacoPassiveLevels'); loadedPassiveLevels = savedPassiveLevelsRaw ? JSON.parse(savedPassiveLevelsRaw) : {}; console.log("[DEBUG] Passive Levels: Raw=", savedPassiveLevelsRaw, "Parsed:", loadedPassiveLevels);
                console.log("[DEBUG] --- Loading persistent data SUCCESS ---");
            } catch (e) { console.error("!!!!!!!! ERROR loading/parsing persistent data:", e); highscore = 0; breados = 0; bestCombo = 0; unlockedAbilities = ['slowMo']; loadedAbilityLevels = {}; loadedPassiveLevels = {}; console.warn("[DEBUG] Resetting to default values due to loading error."); }
            abilities.forEach(a => { a.level = loadedAbilityLevels[a.id] || 0; }); // Wende Level direkt an
            Object.keys(passiveUpgrades).forEach(id => { passiveUpgrades[id].level = loadedPassiveLevels[id] || 0; }); // Wende Level direkt an
            populateShopMenu(); populateMyAbilitiesMenu(); populateUpgradesMenu(); // Erstelle Men√º-HTML
            resetSpiel(); // Setze Spielzustand zur√ºck (nutzt jetzt die geladenen Level)
            console.log("[DEBUG] Baco Game Initialized.");
        }
        initialisiereUI();
        resizeCanvas();
    </script>

</body>
</html>
